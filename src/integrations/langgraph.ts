import { CGateClient } from '../client';
import {
  CGateClientOptions,
  TracingAgent,
  TracingEvent,
  TracingSessionRequest,
  TracingSummary,
  TracingSection,
} from '../types';

// ============================================================================
// LangGraph Tracing Types
// ============================================================================

/**
 * Configuration options for LangGraph tracing
 */
export interface CGateLangGraphTracingOptions {
  /** SDK client or configuration used to build one. */
  client: CGateClient | CGateClientOptions;
  /** Session identifier; autogenerated if omitted. */
  sessionId?: string;
  /** Agent descriptor stored with the session. */
  agent?: TracingAgent;
  /** Initial summary to send alongside events. */
  summary?: TracingSummary;
  /** Optional config blob stored on the session. */
  config?: Record<string, unknown>;
  /** Auto flush events on node completion. */
  autoFlush?: boolean;
  /** Enable debug mode for detailed logging */
  debug?: boolean;
  /** Optional logger; defaults to console.log */
  logger?: (...args: unknown[]) => void;
}

/**
 * Node execution context for tracing
 */
export interface NodeExecutionContext {
  nodeId: string;
  nodeName: string;
  startTime: number;
  input?: Record<string, unknown>;
}

/**
 * Graph execution context for tracing
 */
export interface GraphExecutionContext {
  graphId: string;
  graphName?: string;
  startTime: number;
  nodes: Map<string, NodeExecutionContext>;
}

/**
 * LangGraph tracing binding result
 */
export interface CGateLangGraphTracingBinding {
  /** Session id for correlation. */
  sessionId: string;
  /** Tracer instance for manual control. */
  tracer: CGateLangGraphTracer;
  /** Wrap a node function with tracing. */
  wrapNode: <T extends (...args: unknown[]) => unknown>(
    nodeName: string,
    fn: T
  ) => T;
  /** Create traced node functions map. */
  traceNodes: <T extends Record<string, (...args: unknown[]) => unknown>>(
    nodes: T
  ) => T;
  /** Start graph execution. */
  startGraph: (graphName?: string, initialState?: Record<string, unknown>) => string;
  /** End graph execution. */
  endGraph: (graphId: string, finalState?: Record<string, unknown>, status?: string) => Promise<void>;
  /** Flush buffered events manually. */
  flush: (status?: string) => Promise<void>;
  /** End the session and flush. */
  end: (status?: string) => Promise<void>;
}

// ============================================================================
// LangGraph Tracer Implementation
// ============================================================================

/**
 * LangGraph tracer that converts node executions into CGate tracing sessions.
 * 
 * Designed to work with @langchain/langgraph StateGraph and provides
 * simple wrappers for node functions to enable tracing.
 * 
 * @example
 * ```typescript
 * import { CGateClient } from '@cognipeer/cgate-sdk';
 * import { createCGateLangGraphTracing } from '@cognipeer/cgate-sdk/integrations/langgraph';
 * import { StateGraph, MessagesAnnotation } from '@langchain/langgraph';
 * 
 * const client = new CGateClient({ apiKey: 'your-api-key' });
 * const tracing = createCGateLangGraphTracing({ client });
 * 
 * // Option 1: Wrap individual nodes
 * const tracedCallModel = tracing.wrapNode('callModel', async (state) => {
 *   const response = await model.invoke(state.messages);
 *   return { messages: [response] };
 * });
 * 
 * // Option 2: Trace all nodes at once
 * const nodes = tracing.traceNodes({
 *   callModel: async (state) => { ... },
 *   tools: async (state) => { ... },
 * });
 * 
 * const graph = new StateGraph(MessagesAnnotation)
 *   .addNode('callModel', nodes.callModel)
 *   .addNode('tools', nodes.tools)
 *   .compile();
 * ```
 */
export class CGateLangGraphTracer {
  private client: CGateClient;
  private sessionId: string;
  private agent?: TracingAgent;
  private autoFlush: boolean;
  private summary: TracingSummary;
  private config?: Record<string, unknown>;
  private events: TracingEvent[] = [];
  private debug: boolean;
  private logger: (...args: unknown[]) => void;
  private graphs: Map<string, GraphExecutionContext> = new Map();
  private nodeSequence: number = 0;
  private sessionStartTime: number;

  constructor(options: CGateLangGraphTracingOptions) {
    this.client =
      options.client instanceof CGateClient
        ? options.client
        : new CGateClient(options.client);
    this.sessionId = options.sessionId || CGateLangGraphTracer.generateId();
    this.agent = options.agent;
    this.summary = options.summary || {};
    this.config = options.config;
    this.autoFlush = options.autoFlush ?? false;
    this.debug = options.debug ?? false;
    this.logger = options.logger || ((...args: unknown[]) => console.log('[cgate:langgraph]', ...args));
    this.sessionStartTime = Date.now();
  }

  /** Get the current session id. */
  getSessionId(): string {
    return this.sessionId;
  }

  /** Start tracking a new graph execution. */
  startGraph(graphName?: string, initialState?: Record<string, unknown>): string {
    const graphId = CGateLangGraphTracer.generateId();
    const context: GraphExecutionContext = {
      graphId,
      graphName,
      startTime: Date.now(),
      nodes: new Map(),
    };
    this.graphs.set(graphId, context);

    this.recordEvent({
      type: 'chain_start',
      label: graphName || 'LangGraph',
      metadata: {
        graphId,
        initialState: this.sanitizeState(initialState),
      },
    });

    this.debugLog('graph:start', { graphId, graphName });
    return graphId;
  }

  /** End tracking a graph execution. */
  async endGraph(
    graphId: string,
    finalState?: Record<string, unknown>,
    status: string = 'success'
  ): Promise<void> {
    const context = this.graphs.get(graphId);
    if (!context) {
      this.logger('warning: graph not found', graphId);
      return;
    }

    const duration = Date.now() - context.startTime;
    this.recordEvent({
      type: 'chain_end',
      label: context.graphName || 'LangGraph',
      status: status as TracingEvent['status'],
      durationMs: duration,
      metadata: {
        graphId,
        finalState: this.sanitizeState(finalState),
        nodesExecuted: Array.from(context.nodes.keys()),
      },
    });

    this.graphs.delete(graphId);
    this.debugLog('graph:end', { graphId, duration, status });

    if (this.autoFlush) {
      await this.flush(status);
    }
  }

  /** Record the start of a node execution. */
  startNode(nodeName: string, state?: Record<string, unknown>): string {
    const nodeId = CGateLangGraphTracer.generateId();
    const context: NodeExecutionContext = {
      nodeId,
      nodeName,
      startTime: Date.now(),
      input: this.sanitizeState(state),
    };

    // Add to all active graphs
    for (const graph of this.graphs.values()) {
      graph.nodes.set(nodeId, context);
    }

    this.nodeSequence++;
    this.recordEvent({
      type: 'ai_call',
      label: nodeName,
      sequence: this.nodeSequence,
      status: 'running',
      metadata: {
        nodeId,
        nodeName,
        input: this.sanitizeState(state),
      },
      sections: [
        {
          kind: 'message',
          label: 'Node Input',
          content: JSON.stringify(this.sanitizeState(state), null, 2),
        },
      ],
    });

    this.debugLog('node:start', { nodeId, nodeName });
    return nodeId;
  }

  /** Record the end of a node execution. */
  async endNode(
    nodeId: string,
    output?: Record<string, unknown>,
    status: string = 'success'
  ): Promise<void> {
    let context: NodeExecutionContext | undefined;

    // Find the node context
    for (const graph of this.graphs.values()) {
      if (graph.nodes.has(nodeId)) {
        context = graph.nodes.get(nodeId);
        break;
      }
    }

    if (!context) {
      this.logger('warning: node not found', nodeId);
      return;
    }

    const duration = Date.now() - context.startTime;
    this.nodeSequence++;

    const sections: TracingSection[] = [];
    if (context.input) {
      sections.push({
        kind: 'message',
        label: 'Input',
        content: JSON.stringify(context.input, null, 2),
      });
    }
    if (output) {
      sections.push({
        kind: 'message',
        label: 'Output',
        content: JSON.stringify(this.sanitizeState(output), null, 2),
      });
    }

    this.recordEvent({
      type: 'ai_call',
      label: context.nodeName,
      sequence: this.nodeSequence,
      status: status as TracingEvent['status'],
      durationMs: duration,
      metadata: {
        nodeId,
        nodeName: context.nodeName,
        output: this.sanitizeState(output),
      },
      sections,
    });

    // Update summary
    if (!this.summary.eventCounts) {
      this.summary.eventCounts = {};
    }
    const nodeCount = this.summary.eventCounts[context.nodeName] || 0;
    this.summary.eventCounts[context.nodeName] = nodeCount + 1;

    this.debugLog('node:end', { nodeId, nodeName: context.nodeName, duration, status });

    if (this.autoFlush) {
      await this.flush('running');
    }
  }

  /** Record a node error. */
  async errorNode(nodeId: string, error: unknown): Promise<void> {
    let context: NodeExecutionContext | undefined;

    for (const graph of this.graphs.values()) {
      if (graph.nodes.has(nodeId)) {
        context = graph.nodes.get(nodeId);
        break;
      }
    }

    const errorMessage = this.stringifyError(error);
    const duration = context ? Date.now() - context.startTime : 0;

    this.recordEvent({
      type: 'error',
      label: context?.nodeName || 'Unknown Node',
      status: 'error',
      durationMs: duration,
      error: errorMessage,
      metadata: {
        nodeId,
        nodeName: context?.nodeName,
        error: errorMessage,
      },
    });

    this.debugLog('node:error', { nodeId, error: errorMessage });
    await this.flush('error');
  }

  /** Record a tool call within a node. */
  recordToolCall(
    toolName: string,
    args?: Record<string, unknown>,
    result?: unknown,
    durationMs?: number
  ): void {
    this.nodeSequence++;
    
    const sections: TracingSection[] = [
      {
        kind: 'tool_call',
        label: toolName,
        toolName,
        args,
      },
    ];

    if (result !== undefined) {
      sections.push({
        kind: 'tool_result',
        label: `${toolName} Result`,
        toolName,
        result,
      });
    }

    this.recordEvent({
      type: 'tool_call',
      label: toolName,
      sequence: this.nodeSequence,
      status: 'success',
      durationMs,
      toolName,
      metadata: {
        toolName,
        args,
        result: this.sanitizeState(result as Record<string, unknown>),
      },
      sections,
    });

    this.debugLog('tool:call', { toolName, durationMs });
  }

  /** Record an LLM call within a node. */
  recordLLMCall(
    modelName: string,
    inputTokens?: number,
    outputTokens?: number,
    durationMs?: number
  ): void {
    this.nodeSequence++;

    this.recordEvent({
      type: 'ai_call',
      label: modelName,
      sequence: this.nodeSequence,
      status: 'success',
      durationMs,
      inputTokens,
      outputTokens,
      totalTokens: (inputTokens || 0) + (outputTokens || 0),
      model: modelName,
      modelName,
    });

    // Update summary
    this.summary.totalInputTokens = (this.summary.totalInputTokens || 0) + (inputTokens || 0);
    this.summary.totalOutputTokens = (this.summary.totalOutputTokens || 0) + (outputTokens || 0);

    this.debugLog('llm:call', { modelName, inputTokens, outputTokens, durationMs });
  }

  /**
   * Wrap a node function with automatic tracing.
   * 
   * @example
   * ```typescript
   * const tracedNode = tracer.wrapNode('myNode', async (state) => {
   *   return { ...state, processed: true };
   * });
   * ```
   */
  wrapNode<T extends (...args: unknown[]) => unknown>(nodeName: string, fn: T): T {
    const tracer = this;
    
    const wrapped = async function (...args: unknown[]): Promise<unknown> {
      const state = args[0] as Record<string, unknown>;
      const nodeId = tracer.startNode(nodeName, state);
      
      try {
        const result = await fn(...args);
        await tracer.endNode(nodeId, result as Record<string, unknown>, 'success');
        return result;
      } catch (error) {
        await tracer.errorNode(nodeId, error);
        throw error;
      }
    };

    return wrapped as T;
  }

  /**
   * Trace multiple node functions at once.
   * 
   * @example
   * ```typescript
   * const nodes = tracer.traceNodes({
   *   callModel: async (state) => { ... },
   *   executeTools: async (state) => { ... },
   * });
   * ```
   */
  traceNodes<T extends Record<string, (...args: unknown[]) => unknown>>(nodes: T): T {
    const traced: Record<string, (...args: unknown[]) => unknown> = {};
    
    for (const [name, fn] of Object.entries(nodes)) {
      traced[name] = this.wrapNode(name, fn);
    }
    
    return traced as T;
  }

  /** Flush buffered events to the tracing API. */
  async flush(status: string = 'running'): Promise<void> {
    if (!this.events.length) return;

    const duration = Date.now() - this.sessionStartTime;
    this.summary.totalDurationMs = duration;

    const payload: TracingSessionRequest = {
      sessionId: this.sessionId,
      agent: this.agent,
      config: this.config,
      summary: this.summary,
      status: status as TracingSessionRequest['status'],
      durationMs: duration,
      events: [...this.events],
    };

    this.debugLog('flush', { eventCount: this.events.length, status });

    try {
      await this.client.tracing.ingest(payload);
      this.events = [];
    } catch (error) {
      this.logger('flush error:', this.stringifyError(error));
    }
  }

  /** End the session and flush all events. */
  async endSession(status: string = 'success'): Promise<void> {
    // End any active graphs
    for (const graphId of this.graphs.keys()) {
      await this.endGraph(graphId, undefined, status);
    }

    await this.flush(status);
    this.logger('session ended:', this.sessionId);
  }

  // ============================================================================
  // Private Methods
  // ============================================================================

  private recordEvent(event: Partial<TracingEvent>): void {
    this.events.push({
      id: event.id || CGateLangGraphTracer.generateId(),
      sessionId: this.sessionId,
      timestamp: event.timestamp || new Date().toISOString(),
      ...event,
    } as TracingEvent);
  }

  private sanitizeState(state?: Record<string, unknown>): Record<string, unknown> | undefined {
    if (!state) return undefined;
    
    try {
      // Remove circular references and non-serializable values
      return JSON.parse(JSON.stringify(state, (_key, value) => {
        if (typeof value === 'function') return '[Function]';
        if (value instanceof Error) return { message: value.message, name: value.name };
        if (value instanceof Map) return Object.fromEntries(value);
        if (value instanceof Set) return Array.from(value);
        return value;
      }));
    } catch {
      return { error: 'Unable to serialize state' };
    }
  }

  private stringifyError(error: unknown): string {
    if (error instanceof Error) return error.message;
    if (typeof error === 'string') return error;
    try {
      return JSON.stringify(error);
    } catch {
      return String(error);
    }
  }

  private debugLog(...args: unknown[]): void {
    if (this.debug) {
      this.logger('[debug]', ...args);
    }
  }

  static generateId(): string {
    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
      return crypto.randomUUID();
    }
    return `lg-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Create a CGate LangGraph tracing binding.
 * 
 * This is the main entry point for adding tracing to LangGraph flows.
 * 
 * @example
 * ```typescript
 * import { CGateClient, createCGateLangGraphTracing } from '@cognipeer/cgate-sdk';
 * import { StateGraph, MessagesAnnotation, START, END } from '@langchain/langgraph';
 * 
 * const client = new CGateClient({ apiKey: 'your-api-key' });
 * 
 * const tracing = createCGateLangGraphTracing({
 *   client,
 *   agent: {
 *     name: 'my-langgraph-agent',
 *     version: '1.0.0',
 *   },
 *   debug: true,
 * });
 * 
 * // Define your node functions
 * async function callModel(state) {
 *   const response = await model.invoke(state.messages);
 *   return { messages: [response] };
 * }
 * 
 * async function executeTools(state) {
 *   // Tool execution logic
 *   return { messages: [...] };
 * }
 * 
 * // Wrap nodes with tracing
 * const nodes = tracing.traceNodes({
 *   callModel,
 *   executeTools,
 * });
 * 
 * // Build the graph
 * const graph = new StateGraph(MessagesAnnotation)
 *   .addNode('callModel', nodes.callModel)
 *   .addNode('executeTools', nodes.executeTools)
 *   .addEdge(START, 'callModel')
 *   .addConditionalEdges('callModel', shouldContinue)
 *   .addEdge('executeTools', 'callModel')
 *   .compile();
 * 
 * // Run with tracing
 * const graphId = tracing.startGraph('MyAgent');
 * try {
 *   const result = await graph.invoke({ messages: [...] });
 *   await tracing.endGraph(graphId, result);
 * } catch (error) {
 *   await tracing.endGraph(graphId, undefined, 'error');
 * }
 * 
 * // Don't forget to end the session
 * await tracing.end();
 * ```
 */
export function createCGateLangGraphTracing(
  options: CGateLangGraphTracingOptions
): CGateLangGraphTracingBinding {
  const tracer = new CGateLangGraphTracer(options);

  return {
    sessionId: tracer.getSessionId(),
    tracer,
    wrapNode: <T extends (...args: unknown[]) => unknown>(name: string, fn: T) =>
      tracer.wrapNode(name, fn),
    traceNodes: <T extends Record<string, (...args: unknown[]) => unknown>>(nodes: T) =>
      tracer.traceNodes(nodes),
    startGraph: (graphName?: string, initialState?: Record<string, unknown>) =>
      tracer.startGraph(graphName, initialState),
    endGraph: (graphId: string, finalState?: Record<string, unknown>, status?: string) =>
      tracer.endGraph(graphId, finalState, status),
    flush: (status?: string) => tracer.flush(status),
    end: (status?: string) => tracer.endSession(status),
  };
}

/**
 * Create a simple graph execution wrapper with automatic tracing.
 * 
 * @example
 * ```typescript
 * const tracedInvoke = createTracedGraphInvoker(tracing, 'MyAgent');
 * 
 * // Use like normal invoke but with automatic tracing
 * const result = await tracedInvoke(graph, { messages: [...] });
 * ```
 */
export function createTracedGraphInvoker(
  tracing: CGateLangGraphTracingBinding,
  graphName?: string
) {
  return async function tracedInvoke<TState>(
    graph: { invoke: (input: TState) => Promise<TState> },
    input: TState
  ): Promise<TState> {
    const graphId = tracing.startGraph(graphName, input as Record<string, unknown>);
    
    try {
      const result = await graph.invoke(input);
      await tracing.endGraph(graphId, result as Record<string, unknown>, 'success');
      return result;
    } catch (error) {
      await tracing.endGraph(graphId, undefined, 'error');
      throw error;
    }
  };
}

/**
 * Create a stream wrapper with automatic tracing.
 * 
 * @example
 * ```typescript
 * const tracedStream = createTracedGraphStreamer(tracing, 'MyAgent');
 * 
 * for await (const chunk of tracedStream(graph, { messages: [...] })) {
 *   console.log(chunk);
 * }
 * ```
 */
export function createTracedGraphStreamer(
  tracing: CGateLangGraphTracingBinding,
  graphName?: string
) {
  return async function* tracedStream<TState>(
    graph: { stream: (input: TState) => AsyncGenerator<TState> },
    input: TState
  ): AsyncGenerator<TState> {
    const graphId = tracing.startGraph(graphName, input as Record<string, unknown>);
    
    try {
      const stream = graph.stream(input);
      let lastChunk: TState | undefined;
      
      for await (const chunk of stream) {
        lastChunk = chunk;
        yield chunk;
      }
      
      await tracing.endGraph(graphId, lastChunk as Record<string, unknown>, 'success');
    } catch (error) {
      await tracing.endGraph(graphId, undefined, 'error');
      throw error;
    }
  };
}
